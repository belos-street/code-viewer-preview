var f=Object.defineProperty;var h=(a,n,s)=>n in a?f(a,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[n]=s;var r=(a,n,s)=>h(a,typeof n!="symbol"?n+"":n,s);import{k as t}from"./index-Dhdpvayi.js";/* empty css               */class d{tokenize(n){const s=[],o=/([\\w$]+|[\(\)\[\]\{\}\;\:\,\.]|\s+|.)/g;let i;for(;(i=o.exec(n))!==null;){const e=i[0];/^\s+$/.test(e)?s.push(t("span",{},e)):/^[\(\)\[\]\{\}\;\:\,\.]$/.test(e)?s.push(t("span",{class:"token punctuation"},e)):s.push(t("span",{},e))}return s}}class k{create(){return new d}}class p{constructor(){r(this,"keywords",["var","let","const","function","class","extends","return","if","else","for","while","do","switch","case","default","break","continue","new","try","catch","finally","throw","typeof","instanceof","in","of","delete","void","async","await","yield","import","export","from","as","default","get","set","static","super","this","null","undefined","true","false"])}tokenize(n){const s=[],o=/(\/\/.*|\/\*[\s\S]*?\*\/|"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|`(?:\\.|[^`])*`|[\w$]+|[\(\)\[\]\{\}\;\:\,\.\+\-\*\/\%\!\=\<\>\&\|\^\~\?]|\s+|.)/g;let i;for(;(i=o.exec(n))!==null;){const e=i[0];/^\s+$/.test(e)?s.push(t("span",{},e)):/^\/\/.*$/.test(e)||/^\/\*[\s\S]*?\*\/$/.test(e)?s.push(t("span",{class:"token comment"},e)):/^"(?:\\.|[^"])*"$/.test(e)||/^'(?:\\.|[^'])*'$/.test(e)||/^`(?:\\.|[^`])*`$/.test(e)?s.push(t("span",{class:"token string"},e)):/^\d+(?:\.\d+)?$/.test(e)?s.push(t("span",{class:"token number"},e)):this.keywords.includes(e)?s.push(t("span",{class:"token keyword"},e)):/^[\w$]+$/.test(e)&&/^[A-Z]/.test(e)?s.push(t("span",{class:"token class-name"},e)):/^[\w$]+$/.test(e)?s.push(t("span",{class:"token identifier"},e)):/^[\(\)\[\]\{\}\;\:\,\.]$/.test(e)?s.push(t("span",{class:"token punctuation"},e)):/^[\+\-\*\/\%\!\=\<\>\&\|\^\~\?]$/.test(e)?s.push(t("span",{class:"token operator"},e)):s.push(t("span",{},e))}return s}}class w{create(){return new p}}class m extends p{constructor(){super(...arguments);r(this,"typescriptKeywords",["interface","type","namespace","declare","abstract","implements","readonly","private","protected","public","override","any","unknown","never","enum","keyof","typeof","infer","is","as","satisfies"])}tokenize(s){return super.tokenize(s)}}class y{create(){return new m}}class ${constructor(){r(this,"keywords",["and","as","assert","async","await","break","class","continue","def","del","elif","else","except","False","finally","for","from","global","if","import","in","is","lambda","None","nonlocal","not","or","pass","raise","return","True","try","while","with","yield"]);r(this,"builtins",["abs","all","any","bin","bool","bytearray","bytes","chr","classmethod","compile","complex","dict","dir","divmod","enumerate","eval","exec","filter","float","format","frozenset","getattr","globals","hasattr","hash","help","hex","id","input","int","isinstance","issubclass","iter","len","list","locals","map","max","memoryview","min","next","object","oct","open","ord","pow","print","property","range","repr","reversed","round","set","setattr","slice","sorted","staticmethod","str","sum","super","tuple","type","vars","zip"])}tokenize(n){const s=[],o=/(#.*|"""[\s\S]*?"""|'''[\s\S]*?'''|"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|[\w\.]+|[\(\)\[\]\{\}\;\:\,\.\+\-\*\/\%\!\=\<\>\&\|\^\~\?]|\s+|.)/g;let i;for(;(i=o.exec(n))!==null;){const e=i[0];/^\s+$/.test(e)?s.push(t("span",{},e)):/^#.*$/.test(e)||/^"""[\s\S]*?"""$/.test(e)||/^'''[\s\S]*?'''$/.test(e)?s.push(t("span",{class:"token comment"},e)):/^"(?:\\.|[^"])*"$/.test(e)||/^'(?:\\.|[^'])*'$/.test(e)?s.push(t("span",{class:"token string"},e)):/^\d+(?:\.\d+)?$/.test(e)?s.push(t("span",{class:"token number"},e)):this.keywords.includes(e)?s.push(t("span",{class:"token keyword"},e)):this.builtins.includes(e)?s.push(t("span",{class:"token builtin"},e)):/^def\s+([\w_]+)/.test(e)?s.push(t("span",{class:"token function"},e)):/^class\s+([\w_]+)/.test(e)?s.push(t("span",{class:"token class-name"},e)):/^[\w\.]+$/.test(e)?s.push(t("span",{class:"token identifier"},e)):/^[\(\)\[\]\{\}\;\:\,\.]$/.test(e)?s.push(t("span",{class:"token punctuation"},e)):/^[\+\-\*\/\%\!\=\<\>\&\|\^\~\?]$/.test(e)?s.push(t("span",{class:"token operator"},e)):s.push(t("span",{},e))}return s}}class g{create(){return new $}}class b{constructor(){r(this,"keywords",["abstract","assert","boolean","break","byte","case","catch","char","class","const","continue","default","do","double","else","enum","extends","final","finally","float","for","if","implements","import","instanceof","int","interface","long","native","new","package","private","protected","public","return","short","static","strictfp","super","switch","synchronized","this","throw","throws","transient","try","void","volatile","while","true","false","null"]);r(this,"annotations",["Override","Deprecated","SuppressWarnings","FunctionalInterface","SafeVarargs","Retention","Documented","Target","Inherited","Native","Repeatable"])}tokenize(n){const s=[],o=/(\@[\w\.]+|\/\/.*|\/\*[\s\S]*?\*\/|"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|[\w\.]+|[\(\)\[\]\{\}\;\:\,\.\+\-\*\/\%\!\=\<\>\&\|\^\~\?]|\s+|.)/g;let i;for(;(i=o.exec(n))!==null;){const e=i[0];/^\s+$/.test(e)?s.push(t("span",{},e)):/^\@([\w\.]+)$/.test(e)?s.push(t("span",{class:"token annotation"},e)):/^\/\/.*$/.test(e)||/^\/\*[\s\S]*?\*\/$/.test(e)?s.push(t("span",{class:"token comment"},e)):/^"(?:\\.|[^"])*"$/.test(e)||/^'(?:\\.|[^'])*'$/.test(e)?s.push(t("span",{class:"token string"},e)):/^\d+(?:\.\d+)?$/.test(e)?s.push(t("span",{class:"token number"},e)):this.keywords.includes(e)?s.push(t("span",{class:"token keyword"},e)):/^[A-Z][\w$]*$/.test(e)?s.push(t("span",{class:"token class-name"},e)):/^[a-z][\w$]*(?=\s*\()/.test(e)?s.push(t("span",{class:"token function"},e)):/^[\w\.]+$/.test(e)?s.push(t("span",{class:"token identifier"},e)):/^[\(\)\[\]\{\}\;\:\,\.]$/.test(e)?s.push(t("span",{class:"token punctuation"},e)):/^[\+\-\*\/\%\!\=\<\>\&\|\^\~\?]$/.test(e)?s.push(t("span",{class:"token operator"},e)):s.push(t("span",{},e))}return s}}class x{create(){return new b}}class z{constructor(){r(this,"keywords",["break","default","func","interface","select","case","defer","go","map","struct","chan","else","goto","package","switch","const","fallthrough","if","range","type","continue","for","import","return","var","nil","true","false"]);r(this,"builtinTypes",["bool","byte","complex64","complex128","error","float32","float64","int","int8","int16","int32","int64","rune","string","uint","uint8","uint16","uint32","uint64","uintptr"]);r(this,"builtinFuncs",["append","cap","close","complex","copy","delete","imag","len","make","new","panic","print","println","real","recover"])}tokenize(n){const s=[],o=/(\/\/.*|\/\*[\s\S]*?\*\/|"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|`(?:\\.|[^`])*`|[\w\.]+|[\(\)\[\]\{\}\;\:\,\.\+\-\*\/\%\!\=\<\>\&\|\^\~\?]|\s+|.)/g;let i;for(;(i=o.exec(n))!==null;){const e=i[0];/^\s+$/.test(e)?s.push(t("span",{},e)):/^\/\/.*$/.test(e)||/^\/\*[\s\S]*?\*\/$/.test(e)?s.push(t("span",{class:"token comment"},e)):/^"(?:\\.|[^"])*"$/.test(e)||/^'(?:\\.|[^'])*'$/.test(e)||/^`(?:\\.|[^`])*`$/.test(e)?s.push(t("span",{class:"token string"},e)):/^\d+(?:\.\d+)?$/.test(e)?s.push(t("span",{class:"token number"},e)):this.keywords.includes(e)?s.push(t("span",{class:"token keyword"},e)):this.builtinTypes.includes(e)?s.push(t("span",{class:"token builtin-type"},e)):this.builtinFuncs.includes(e)?s.push(t("span",{class:"token builtin"},e)):/^func\s+([\w$]+)/.test(e)?s.push(t("span",{class:"token function"},e)):/^type\s+([\w$]+)/.test(e)?s.push(t("span",{class:"token class-name"},e)):/^[\w\.]+$/.test(e)?s.push(t("span",{class:"token identifier"},e)):/^[\(\)\[\]\{\}\;\:\,\.]$/.test(e)?s.push(t("span",{class:"token punctuation"},e)):/^[\+\-\*\/\%\!\=\<\>\&\|\^\~\?]$/.test(e)?s.push(t("span",{class:"token operator"},e)):s.push(t("span",{},e))}return s}}class v{create(){return new z}}class u{constructor(){r(this,"keywords",["auto","break","case","char","const","continue","default","do","double","else","enum","extern","float","for","goto","if","int","long","register","return","short","signed","sizeof","static","struct","switch","typedef","union","unsigned","void","volatile","while","NULL","true","false"]);r(this,"preprocessor",["include","define","undef","if","ifdef","ifndef","else","elif","endif","line","error","pragma"])}tokenize(n){const s=[],o=/(#[\w]+|\b[\w]+\b|\/\/.*|\/\*[\s\S]*?\*\/|"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|[\w\.]+|[\(\)\[\]\{\}\;\:\,\.\+\-\*\/\%\!\=\<\>\&\|\^\~\?]|\s+|.)/g;let i;for(;(i=o.exec(n))!==null;){const e=i[0];if(/^\s+$/.test(e))s.push(t("span",{},e));else if(/^#([\w]+)/.test(e)){const l=e.substring(1);this.preprocessor.includes(l)?s.push(t("span",{class:"token preprocessor"},e)):s.push(t("span",{},e))}else/^\/\/.*$/.test(e)||/^\/\*[\s\S]*?\*\/$/.test(e)?s.push(t("span",{class:"token comment"},e)):/^"(?:\\.|[^"])*"$/.test(e)||/^'(?:\\.|[^'])*'$/.test(e)?s.push(t("span",{class:"token string"},e)):/^\d+(?:\.\d+)?$/.test(e)?s.push(t("span",{class:"token number"},e)):this.keywords.includes(e)?s.push(t("span",{class:"token keyword"},e)):/^[\w]+(?=\s*\()/.test(e)?s.push(t("span",{class:"token function"},e)):/^[\w\.]+$/.test(e)?s.push(t("span",{class:"token identifier"},e)):/^[\(\)\[\]\{\}\;\:\,\.]$/.test(e)?s.push(t("span",{class:"token punctuation"},e)):/^[\+\-\*\/\%\!\=\<\>\&\|\^\~\?]$/.test(e)?s.push(t("span",{class:"token operator"},e)):s.push(t("span",{},e))}return s}}class T{create(){return new u}}class S extends u{constructor(){super(...arguments);r(this,"cppKeywords",["alignas","alignof","and","and_eq","asm","atomic_cancel","atomic_commit","atomic_noexcept","bitand","bitor","bool","catch","class","compl","concept","consteval","constexpr","constinit","const_cast","co_await","co_return","co_yield","decltype","delete","dynamic_cast","explicit","export","false","friend","inline","mutable","namespace","new","noexcept","not","not_eq","nullptr","operator","or","or_eq","private","protected","public","reflexpr","reinterpret_cast","requires","static_assert","static_cast","synchronized","template","this","thread_local","throw","true","try","typeid","typename","using","virtual","wchar_t","xor","xor_eq"])}tokenize(s){return super.tokenize(s)}}class _{create(){return new S}}const c={generic:new k,javascript:new w,typescript:new y,python:new g,java:new x,go:new v,c:new T,cpp:new _},F=(a,n)=>{const s=(n==null?void 0:n.toLowerCase())||"generic";return(c[s]||c.generic).create().tokenize(a)},C={name:"syntax-highlight",install(){},processedLines(a){var i;const{visibleLines:n,language:s}=a,o={};for(const e of n.value){if((i=e.meta)!=null&&i.disableSyntaxHighlight)continue;const l=F(e.content,s);o[e.id]=[{container:"line-content",content:l,pluginName:C.name}]}return o},uninstall(){}};export{C as S};
